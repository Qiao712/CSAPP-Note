## 链接
将各种代码和数据片段收集并组合成一个单一文件的过程。

* 可执行于 编译时、加载时、运行时

* 编译驱动程序（compiler driver） 自动调用 预处理器、 编译器、汇编器、链接器.
```shell
gcc -o prog main.c other.c
```
	* main.c -> cpp(预处理器) -> cc1(C编译器) -> as(汇编器) -> main.o(可重定位目标文件)
	* other.c -> ... -> other.o
	* other.o + main.c ->ld(链接器) -> prog（可执行目标文件executable object file）
* 由系统的 加载器（loader）函数 加载并开始执行程序
* Linux LD 为**静态链接器（static linker）** 输入一组 可重定位目标文件，生成一个完全链接的、可加载和运行的可执行目标文件。
* 目标文件：可重定位目标文件、 可执行目标文件、共享目标文件
	* Windows使用 可移植可执行(Portable Executable,PE)格式
	* x86-64 Linux 和 Unix 使用 可执行可链接格式(Executable and Linkable Format) ELF
* ELF可重定位目标文件 的 节：
	* .text 已编译程序的机器码
	* .rodata 只读数据，（字面值的字符串等）
	* .data 已初始化的全局和静态变量
	* .bss 未初始化的全局和静态变量
	* .symtab 符号表，程序定义和引用的函数和全局变量
	* .rel.text 用于重定位。.text中需要修改的位置的列表 以及 对应的重定位所需要的信息（所重定位符号的名字、大小、类型等）
	* .rel.data 用于重定位.data中的内容，同.rel.text（如全局变量的初始值未一个全局变量的地址或函数地址）
	* .debug 调试符号表 *只有以-g选项编译才会带此表*
	* .line 源文件中行号与.text节中机器指令的映射 *只有以-g选项编译才会带此表*
	* .strlab 字符串表 .symtab 和 .debug 中的符号表等中的名字
* 符号：
	* 全局符号：非静态函数、全局变量
	* 外部符号：在其他模块定义，在此模块引用的全局符号
	* 局部符号： （static修饰的）静态函数和全局变量，仅在本模块中可见，不能被其他模块引用
	* 非静态的局部变量不在.symtab中，由栈管理，链接器不处理此类符号
* 链接器主要完成： 符号解析（symbol resolution） 重定位（relocation）
	* 符号解析：每个符号对应于一个*函数、全局变量、静态变量*。符号解析将每个符号引用正好和一个符号定义关联起来。
		* 编译时，编译器指示每个全局符号的**强**、**弱**，汇编器将这些信息编码在可重定位目标文件的符号表中。**已初始化的全局变量 和 函数 是 强符号， 未初始化的全局变量是弱符号。**
		* 链接器根据符号的强弱处理多重定义的符号名： 
			* 不允许有多个同名的强符号
			* 优先选择强符号
			* 如果有多个弱符号而没有强符号，则随意选择一个弱符号
	* 重定位： 符号解析完成后，将所有输入的模块中同样类型的节聚合成新的节。然后把每个符号定义与一个内存地址关联起来，然后修改所有节中对这些符号的引用，使其指向这个内存地址。根据.rel.text节和.rel.data节中的*重定位条目（relocation entry)*找到需要修改的引用并修改。 
* 静态库（static library）: 将多个目标模块打包。作为链接器输入时，只复制其中被程序引用的目标模块。
	* Linux中，静态库以存档（archive）文件格式储存(.a)
	* C标准库函数被打包在libc.a库中 （默认链接该库）
	* 使用AR工具建立静态库,一般命名格式libxxx.a
	```shell
	ar rcs libtest.a test1.o test2.o
	```
	* 链接静态库
	```shell
	gcc -static -o prog main.c ./libtest.a
	或
	gcc -static -o prog main.c -ltest
	```
	-static 要求链接器生成完全链接的可执行目标文件，加载时无需进一步的链接

	
